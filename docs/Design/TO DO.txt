TO DO:

DONE * Move Pots up above Hand
DONE * Handle raise (easiest as doesn't trigger end of round)
DONE * Handle call/see (match current pot, could trigger end of round)
DONE * Handle check (as first player to bet, or to 'call' a previous player's check, could trigger end of round)
DONE * Handle fold (could trigger end of round or end of game)
DONE * Handle evaluation of hand of 6 or 7 cards (work out which is the best 5 card hand of all 6 or 21 combinations)
DONE * Show a one-line representation of the full set of cards, not just the best hand of 5
DONE * Fix plurals, esp. "Sixs"
DONE * Handle end of hand (i.e. end of seventh round) -> simple case with one winner
DONE * Handle fold triggering end of hand
DONE * Add a new field Commentary as list of strings (to replace LastEvent eventually)
DONE * Handle end of hand (i.e. end of seventh round) -> multiple winners (shared pot)
DONE * Show final hand in summary
DONE * Handle end of hand (i.e. end of seventh round) -> allow for multiple pots
DONE * Handle covering the pot (is this only when the player cannot match the current bet?)
* Define a cleaner interface between client and server
  - Game state should include:
    - Index of player to make move (done already)
    - List of commands specified player can use (from Join, Start, Check, Raise <n>, Call, Cover, Fold)
    - List of commands any player can use (from Join, Rejoin, Refresh? Leave)
    - Server has to check this anyway on receipt of a command, so might as well do this up front too
* Hand-roll the JSON to make it more compact and readable (and also to support the possibility of JSON targeted to an individual user)
* Test ability to send a message to one player (preserve their connect, and have them wait on individual messages not just on the updated game state)
* Prevent blank or duplicate players joining
* Prevent players joining during the game
* Prevent player from changing name after joining
* Allow player to rejoin
* Handle no one being able to bet (i.e. auto-check, or other auto-enabled actions)
* Handle end of overall game (time limit, number of rounds, less than 'n' players left in)
* Think about regression test framework that processes command in sequence and checks relevant parts of results
* Split hand description out into two parts: main bit e.g. "Ace High" and countback e.g. "with King ..."
* Game name to be pulled from URL
* Find out how to send a message to any one game participant, who may not be the caller
* Check performance of HashTable: consider making GetHashCode cleverer https://thomaslevesque.com/2020/05/15/things-every-csharp-developer-should-know-1-hash-codes/
Validation (on client and/or server)

Find and return next player? Or analyse whole state and determine next action based on e.g. pot contributions?

Use a Hashtable with key = action and value = ActivePlayerOnly, NotAvailable, AnyPlayer

If true then query second hastable with max raise

Should an Action be a class () ... the action could be a superclass with a basic check of user name etc, with subclasses based on the action type

ActionFactory -> instantiates object of type Action based on the action Enum , e.g. ActionJoin


